(a + b) mod M = ((a mod M) + (b mod M)) mod M.
(a - b) mod M = ((a mod M) - (b mod M)) mod M.
(a * b) mod M = ((a mod M) * (b mod M)) mod M.


& The result of AND is 1 only if both bits are 1
| The result of OR is 1 if any of the two bits is 1
^ The result of XOR is 1 if the two bits are different or same number gets cancelled when xor is taken
~ (bitwise NOT) inverts all bits of it.


Important Facts about Bitwise Operators:
The left shift and right shift operators cannot be used with negative numbers.
The bitwise XOR operator is the most useful operator from technical interview perspective.
The bitwise operators should not be used in place of logical operators.
The left-shift and right-shift operators are equivalent to multiplication and division by 2 respectively.

number is odd? -> The value of expression (x & 1) would be non-zero only if x is odd, otherwise the value would be zero.

number of bits in the number -> log2(num) + 1 ... example 4 = 100 ... log2(4)+1 = 3

set a bit at nth position in number 'num' -> num|(1<<n)

unset a bit at nth position in number 'num' -> num&(~(1<<n))
explain: 
First we left shift '1' to n position via (1 << n) than we use bitwise NOT operator '~' to unset this shifted '1'.
Now after clearing this left shifted '1' i.e making it to '0' we will 'AND'(&) with the number 'num' that will unset bit at nth position position.

Toggling a bit at nth position : -> num^(1<<n) ... 1^1 = 0 and 0^1 = 1

Checking if bit at nth position is set or unset -> if(num&(1<<n) == 1){then it is set}

rightmost set bit of a number -> x = num&(~(num-1))
position of rightmost set bit of a number -> log2(x) + 1

Divide by 2: -> x = x >> 1;
Since every bit is a power of 2, with each shift we are reducing the value of each bit by factor of 2 which is equivalent to division of x by 2.

Multiplying by 2: -> x = x << 1;
Since every bit is a power of 2, with each shift we are increasing the value of each bit by a factor of 2 which is equivalent to multiplication of x by 2.

Find log base 2 :
int log2(int x) 
{ 
    int res = 0; 
    while (x >>= 1) 
        res++; 
    return res; 
} 
Logic: We right shift x repeatedly until it becomes 0, meanwhile we keep count on the shift operation. This count value is the log2(x).

Swapping Two Numbers: 
a ^= b;
b ^= a; 
a ^= b;

Flipping/inverting the bits of a number
void invertBits(int num)
{
    // calculating number of bits in the number
    int x = log2(num) + 1;
 
    // Inverting the bits one by one ... by taking XOR at each position
    for (int i = 0; i < x; i++)
       num = (num ^ (1 << i));
  
    cout << num;
}

N is power of 2 or not ->(1st) ((n&(~(n-1))) == n){then yes}...(2nd) ceil(log2(n)) == floor(log2(n)){then yes}

find the most significant set bit in the given number. -> pow(2,log2(N)) ... log2(10) = 3 ... pow(2,3) = 8
Examples:
Input : N = 10
Output : 8
Binary representation of 10 is 1010
The most significant bit corresponds
to decimal number 8.

find the XOR of all numbers from 1 to N.
Examples :
Input : N = 6
Output : 7
// 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6  = 7

Solution:
Find the remainder of N by moduling it with 4.
If rem = 0, then xor will be same as N.
If rem = 1, then xor will be 1.
If rem = 2, then xor will be N+1.
If rem = 3 ,then xor will be 0.
How does this work?
When we do XOR of numbers, we get 0 as XOR value just before a multiple of 4. This keeps repeating before every multiple of 4.
Number Binary-Repr  XOR-from-1-to-n
1         1           [0001]
2        10           [0011]
3        11           [0000]  <----- We get a 0
4       100           [0100]  <----- Equals to n
5       101           [0001]
6       110           [0111]
7       111           [0000]  <----- We get 0
8      1000           [1000]  <----- Equals to n



find the Maximum AND Value generated by any pair of the element from the array
Input: a[] = {4, 8, 12, 16}
Output: 8
The pairs 8 and 12 gives us the '&' value as 12.
Consider three elements {10, 8, 2}, so to get a maximum '&' value we need to take those elements 
whose LSB is as far as possible. In the given example, we can clearly see that 10(1010) and 8(1000) 
have their 4th-bit from the left set and hence will maximize the answer. Taking 2 and 10 will give our 
2nd bit to be set which won't maximize our answer.for 32 bit number we loop from 31 to 0 and check 
for the count of numbers whose that particular bit is set. Once we get the count more than 2, 
the answer will have that bit set, and for the next bit from the left to be set we need to check for both 
the previous all bits and the current i-th bit. The previous bits can be added to the current bit using a '|' operator
// Utility function to check number of elements
// having set msb as of pattern
int checkBit(int pattern, int arr[], int n)
{
    int count = 0;
    for (int i = 0; i < n; i++)
        if ((pattern & arr[i]) == pattern)
            count++;
    return count;
}
 
// Function for finding maximum and value pair
int maxAND (int arr[], int n)
{
    int res = 0;
    int count = 0;

    // iterate over total of 30bits from msb to lsb
    for (int bit = 31; bit >= 0; bit--)
    {
        // find the count of element having set  msb
        count = checkBit(res | (1 << bit),arr,n);
 
        // if count >= 2 set particular bit in result
        if ( count >= 2 )        
            res = res|(1 << bit);        
    }
 
    return res;
}

// cod to print bits
# define M 32

int num = 8;
bitset<M>b1(num);
cout << b1 << endl;

// bits to decimal
stoi("1000", nullptr, 2) -> 4
stoi("1000") -> 1000

any_number^0 = any_number


what is gray -> https://www.geeksforgeeks.org/gray-to-binary-and-binary-to-gray-conversion/
int Binary2Gray(int n)
{
    return n^(n>>1);
}

int Gray2Binary(int n)
    {
        int res = n;
        while(n > 0)
        {
            res = (res^(n>>1));
            n = n>>1;
        }
        return res;
    }
};


all odd bits in a number x -> x&0x55555555; //x ambersand 0x8timesfive
all even bits in a number x -> x&0xAAAAAAAA; //x ambersand 0x8timesCapitalA
//Function to swap odd and even bits.
unsigned int swapBits(unsigned int x)
{
    // Your code here
    unsigned int odd_bits_set = x&0x55555555;
    unsigned int even_bits_set = x&0xAAAAAAAA;
    
    odd_bits_set = odd_bits_set<<1;
    even_bits_set = even_bits_set>>1;
    
    return (odd_bits_set|even_bits_set);
}

from MSB to LSB (32 to 1)

// n: input to count the number of set bits
//Function to return sum of count of set bits in the integers from 1 to n.
// soln link : https://www.youtube.com/watch?v=g6OxU-hRGtY#
int countSetBits(int n)
{
    if(n <= 0)
    {
        return 0;
    }
    // Your logic here
    int x = log2(n);
    int soln = (x*pow(2, x-1)) + (n-(pow(2, x)) + 1) + countSetBits(n-pow(2, x));
    
    return soln;
}
